# W2 Key Points Summary & Homework

### Summary

### Quick Link to Homework

### Examples on Lecture to Review
LC1 两数之和 [LINK](#lc1-两数之和-easy)  
LC874 模拟行走机器人 [LINK](#lc874-模拟行走机器人-easy)

-------
### Hash Table

#### LC1 两数之和 Easy
https://leetcode-cn.com/problems/two-sum/description/
- 主体思路：暴力解法是两层for-loop寻找目标元素解，最坏为O(n^2)，尝试固定i移动j来寻找nums[j] = target - nums[i]
- 细节：
  - 数组中同一个元素在答案里不能重复出现，只能在除了nums[i]以外的其余元素中寻找符合条件的nums[j]
  - 可以按照任意顺序返回答案
  可以设j<i，保证nums[i]不会重复出现，在对i遍历时，在nums(1,...,i-1)中寻找等于target - nums[i]的元素，并返回符合条件的元素的索引和此时的i值
  - 利用hash表对nums数组中的元素值返回对应的索引
```C++
// C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        /* 寻找两个符合条件的目标值，是i, j的两层循环问题
        通过固定i，来寻找一个j使得nums[i] + nums[j] = target
        也就是在nums中寻找有没有元素值等于target - nums[i]
        利用一个映射value_to_index，返回符合条件的元素的数组下标 */ 
        unordered_map<int, int> value_to_index; 
        // 对i遍历
        for (int i = 0; i <= nums.size(); i++){
            // C++中map.find如果未找到结果，则返回尾指针，不等于尾指针则说明有结果
            if (value_to_index.find(target - nums[i]) != value_to_index.end()) {
                return {i, value_to_index[target - nums[i]]}; 
                // 此处value_to_index[target - nums[i]是在nums[0,...,i-1]中寻找
            }
            // 边循环i，边插入，维护对nums[0,...,i-1]的映射
            // 防止对nums[i]的自身映射
            value_to_index[nums[i]] = i; 
        } 
    return {}; // 如果没有符合条件的结果，返回空
    }
};

```

#### 用hash table计算三数之和



-------

#### LC874 模拟行走机器人 Easy
https://leetcode-cn.com/problems/walking-robot-simulation/submissions/

```C++
// C++
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        // 初始化
        int x = 0;
        int y = 0;
        int dir = 0; // 开始时面向北方
        int ans = 0;

        // 生成存放障碍物位置（二元数组）的无序集合blockers，便于访问查询
        // 方案1，改为string
        unordered_set<string> blockers; 
        // 如果用方案2，改为：
        unordered_set<long long> blockers;
        for (auto& obstacle : obstacles){
            blockers.insert(calcHash(obstacle[0], obstacle[1])); // 将hash函数计算后的key作为blockers中的索引
        }

        // 问题重点2: 利用方向数组指导(x, y)的移动方向
        /* 向北移动1时，x不变，y加一
           向东移动1时，x加一，y不变
           向南移动1时，x不变，y减一
           向西移动1时，x减一，y不变
        */
        // 按照北、东、南、西的方位存储x方向和y方向的位置变化
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};

        // 基于commands对(x, y)进行操作
        for (int cmd : commands){
            // 如果cmd > 0，(x, y)向前移动cmd个单位长度
            if (cmd > 0) {
                for (int i = 0; i < cmd; i++){
                    // 计算(x, y)的下一步位置
                    int next_x = x + dx[dir];
                    int next_y = y + dy[dir];
                    // 如果(x, y)的下一步是障碍物位置，那么在这一次cmd下(x, y)位置不变，等待下一次cmd
                    if (blockers.find(calcHash(next_x, next_y)) != blockers.end()) break;
                    // 如果(x, y)的下一步不是障碍物位置，更新(x, y)位置，进行下一步操作
                    x = next_x;
                    y = next_y;
                    // 返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方
                    ans = max(ans, x * x + y * y);
                }
            // 如果cmd = -2，向左转 90 度
            // 方向变化为北->西->南->东->北
            // 对应的dic在方向数组中索引变化为0->3->2->1->0
            }else if(cmd == -2) {
                dir = (dir - 1 + 4) % 4;
            }else
            // 如果cmd = -1，向右转90度
            // 方向变化为北->东->南->西->北
            // 对应的dic在方向数组中索引变化为0->1->2->3->0
            dir = (dir + 1) % 4;
        }
        return ans;
    }

// 问题重点1：判断障碍
// 两个方案：利用hash函数将二元数组转换为string或者大整数，供unordered_set寻找是否有blocker
// 方案1: 转变为string
private:
    string calcHash(int x, int y){
        return to_string(x) + "," + to_string(y); 
    }

// 方案2: 转变为大整数long long
// 将(x, y)看作进制数的第1和第0位，防止为负先平移坐标系再换算
private:
    long long calcHash(int x, int y){
        return (x + 30000) * 60000ll + y + 30000;
    }

};

```























