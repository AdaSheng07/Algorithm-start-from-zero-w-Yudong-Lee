# W2 Key Points Summary & Homework

### Summary

### Quick Link to Homework

### Examples on Lecture to Review
LC1 两数之和 [LINK](#lc1-两数之和-easy)  
LC874 模拟行走机器人 [LINK](#lc874-模拟行走机器人-easy)

-------
### Hash Table

#### LC1 两数之和 Easy
https://leetcode-cn.com/problems/two-sum/description/
- 主体思路：暴力解法是两层for-loop寻找目标元素解，最坏为O(n^2)，尝试固定i移动j来寻找nums[j] = target - nums[i]
- 细节：
  - 数组中同一个元素在答案里不能重复出现，只能在除了nums[i]以外的其余元素中寻找符合条件的nums[j]
  - 可以按照任意顺序返回答案
  可以设j<i，保证nums[i]不会重复出现，在对i遍历时，在nums(1,...,i-1)中寻找等于target - nums[i]的元素，并返回符合条件的元素的索引和此时的i值
  - 利用hash表对nums数组中的元素值返回对应的索引
```C++
// C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        /* 寻找两个符合条件的目标值，是i, j的两层循环问题
        通过固定i，来寻找一个j使得nums[i] + nums[j] = target
        也就是在nums中寻找有没有元素值等于target - nums[i]
        利用一个映射value_to_index，返回符合条件的元素的数组下标 */ 
        unordered_map<int, int> value_to_index; 
        // 对i遍历
        for (int i = 0; i <= nums.size(); i++){
            // C++中map.find如果未找到结果，则返回尾指针，不等于尾指针则说明有结果
            if (value_to_index.find(target - nums[i]) != value_to_index.end()) {
                return {i, value_to_index[target - nums[i]]}; 
                // 此处value_to_index[target - nums[i]是在nums[0,...,i-1]中寻找
            }
            // 边循环i，边插入，维护对nums[0,...,i-1]的映射
            // 防止对nums[i]的自身映射
            value_to_index[nums[i]] = i; 
        } 
    return {}; // 如果没有符合条件的结果，返回空
    }
};

```

#### 用hash table计算三数之和



-------

#### LC874 模拟行走机器人 Easy























