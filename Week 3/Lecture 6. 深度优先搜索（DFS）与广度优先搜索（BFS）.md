## Lecture 6. 深度优先搜索（DFS）与广度优先搜索（BFS）

### 回顾：图的遍历

**深度优先遍历**

![image](https://user-images.githubusercontent.com/86143164/124428095-d26f1a80-dd9e-11eb-8eaa-3340bcce7f12.png)


**Example:**  [课程表](https://leetcode-cn.com/problems/course-schedule/)

- 在学习课程`a[1]`之前必须学习`b[i]`，即在`a[1]`与`b[i]`之间连接一条边
- 什么时候结果为false？在学习`a[1]`之前必须学习`b[i]`，在学习`b[1]`之前必须学习`a[i]`，`a[1]`与`b[i]`互为先修课——**成环**

**广度优先遍历**

-------

### Key Points

- **总结归纳状态、状态空间和把问题抽象为树或图的方法**  
- **搜索是解决一切问题的万金油算法，众多没有多项式时间解法的问题（NP问题）都需要靠搜索求解**  
- **学会定义搜索框架，将极大地帮助学习动态规划和图论算法**  
- **搜索题是训练代码能力最有效的题目类别（DFS、BFS必考）**  

-------

### 状态与状态空间

**状态**
<br/>
- 题面中涉及的所有数学信息
- 在纸上人力计算时，关注的所有数据
- 一个函数访问的所有变量

例如计票问题：给了n个名字，画“正”字统计每个名字出现了多少次，关注的数据有：
- 名字有哪些——n个字符串`string`
- 统计到了哪个名字（第`1 <= i <= n`个名字）
- 画的“正”字（一个用于计数的数据结构，例如hashmap）
- 写成程序：
    ``` C++
    for (int i = 0; i < n; i++){
        count[name[i]]++;
    }
    ```
  - 访问的变量有：`n, name, i, count, hashmap`
  - 只关注**动态变化的**数据，也就是`i`和`count`，以及`hashmap`，`n`和`name`是传入的数据
  - **状态就是程序维护的所有动态数据构成的集合, 一个问题的状态空间就是所有可能状态构成的集合**，例如对于`names = ["Canada", "Alice", "Bob", "Candela"]`有状态空间：
    ![image](https://user-images.githubusercontent.com/86143164/124727457-506b2700-df41-11eb-9f50-0a86dd5b3c7f.png)

将状态作为点，如果从一个状态可以到达另一个状态，就连一条边，这样就吧整个**状态空间**抽象为一张**有向图**，对问题的求解，就是对这张**图的遍历**。  
<br/>
计票问题的状态空间由`n`个状态组成，可以看做一张`n`个点，`n - 1`条边的有向图，整张图是一条链，自然可以用一维循环解决。  
<br/>
怎样遍历比较高效？
<br/>
**状态的简化**

![image](https://user-images.githubusercontent.com/86143164/124727457-506b2700-df41-11eb-9f50-0a86dd5b3c7f.png)

在这里，当`i`固定以后，`count`其实已经被决定了，没有其它可能。`count`对于`i`来说只是一个附加信息，并不影响状态的规模。把可以由其它数据决定的信息从状态中排除，得到的最简状态决定了问题的**复杂度**。

![image](https://user-images.githubusercontent.com/86143164/124730742-354de680-df44-11eb-9077-99cd519fcd8d.png)

在这里，当`i`固定以后，`count`其实已经被决定了，没有其它可能。`count`对于`i`来说只是一个附加信息，并不影响状态的规模。把可以由其它数据决定的信息从状态中排除，得到的最简状态决定了问题的**复杂度**。

比如，子集问题的指数型状态空间：`set = [1, 2, 3], subsets = [[], [1], [2], [3], [1, 2], [2, 3], [1, 2, 3]]`

![image](https://user-images.githubusercontent.com/86143164/124730361-da1bf400-df43-11eb-998d-0b3757b2395f.png)

这是一棵树，也是一张有向图，求所有子集就是遍历这张有向图，到没有出边的最下方`subsets`。

再比如，全排列问题的排列型状态空间：`permutations = [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]`

![image](https://user-images.githubusercontent.com/86143164/124731501-ddfc4600-df44-11eb-9892-5d5c31a319f3.png)

求所有排列也就是遍历这张有向图。

-------

### 搜索

采用直接遍历整个状态空间的方式寻找答案的一类算法，根据遍历状态空间（图）方式的不同，分为：
- 深度优先搜索DFS（Depth First Search）
- 广度优先搜索BFS（Breadth First Search）  

一般来说，每个状态只遍历一次，所以当状态空间是“图”而不是“树时，要**判重**（记忆化）

**搜索题的解题步骤**
1. 纸上模拟，提取信息
2. 定义状态
3. 确定遍历顺序（DFS/BFS）
4. 定义搜索框架     
    - 如果是DFS，状态作为参数，确定递归便捷，注意还原现场
    - 如果是BFS，状态哦那个队列保存
    - 考虑是否需要判重
5. 程序实现

-------

### 深度优先搜索DFS的实现与应用


-------

### 广度优先搜索BFS的实现与应用


-------

### DFS与BFS的对比






















