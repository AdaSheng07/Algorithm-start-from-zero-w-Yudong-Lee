# W2 Key Points Summary & Homework

### Summary

### Quick Link to Homework
LC

### Examples on Lecture to Review
LC1 两数之和 [LINK](#lc1-两数之和-easy)  
LC874 模拟行走机器人 [LINK](#lc874-模拟行走机器人-easy)

-------
### Hash Table

#### LC1 两数之和 Easy
https://leetcode-cn.com/problems/two-sum/description/
- 主体思路：暴力解法是两层for-loop寻找目标元素解，最坏为O(n^2)，尝试固定i移动j来寻找nums[j] = target - nums[i]
- 细节：
  - 数组中同一个元素在答案里不能重复出现，只能在除了nums[i]以外的其余元素中寻找符合条件的nums[j]
  - 可以按照任意顺序返回答案
  可以设j<i，保证nums[i]不会重复出现，在对i遍历时，在nums(1,...,i-1)中寻找等于target - nums[i]的元素，并返回符合条件的元素的索引和此时的i值
  - 利用hash表对nums数组中的元素值返回对应的索引
```C++
// C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        /* 寻找两个符合条件的目标值，是i, j的两层循环问题
        通过固定i，来寻找一个j使得nums[i] + nums[j] = target
        也就是在nums中寻找有没有元素值等于target - nums[i]
        利用一个映射value_to_index，返回符合条件的元素的数组下标 */ 
        unordered_map<int, int> value_to_index; 
        // 对i遍历
        for (int i = 0; i <= nums.size(); i++){
            // C++中map.find如果未找到结果，则返回尾指针，不等于尾指针则说明有结果
            if (value_to_index.find(target - nums[i]) != value_to_index.end()) {
                return {i, value_to_index[target - nums[i]]}; 
                // 此处value_to_index[target - nums[i]是在nums[0,...,i-1]中寻找
            }
            // 边循环i，边插入，维护对nums[0,...,i-1]的映射
            // 防止对nums[i]的自身映射
            value_to_index[nums[i]] = i; 
        } 
    return {}; // 如果没有符合条件的结果，返回空
    }
};

```

#### 用hash table计算三数之和



-------

#### LC874 模拟行走机器人 Easy
https://leetcode-cn.com/problems/walking-robot-simulation/

```C++
// C++
class Solution {
public:
    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        // 初始化
        int x = 0;
        int y = 0;
        int dir = 0; // 开始时面向北方
        int ans = 0;

        // 生成存放障碍物位置（二元数组）的无序集合blockers，便于访问查询
        // 方案1，改为string
        unordered_set<string> blockers; 
        // 如果用方案2，改为：
        unordered_set<long long> blockers;
        for (auto& obstacle : obstacles){
            blockers.insert(calcHash(obstacle[0], obstacle[1])); // 将hash函数计算后的key作为blockers中的索引
        }

        // 问题重点2: 利用方向数组指导(x, y)的移动方向
        /* 向北移动1时，x不变，y加一
           向东移动1时，x加一，y不变
           向南移动1时，x不变，y减一
           向西移动1时，x减一，y不变
        */
        // 按照北、东、南、西的方位存储x方向和y方向的位置变化
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};

        // 基于commands对(x, y)进行操作
        for (int cmd : commands){
            // 如果cmd > 0，(x, y)向前移动cmd个单位长度
            if (cmd > 0) {
                for (int i = 0; i < cmd; i++){
                    // 计算(x, y)的下一步位置
                    int next_x = x + dx[dir];
                    int next_y = y + dy[dir];
                    // 如果(x, y)的下一步是障碍物位置，那么在这一次cmd下(x, y)位置不变，等待下一次cmd
                    if (blockers.find(calcHash(next_x, next_y)) != blockers.end()) break;
                    // 如果(x, y)的下一步不是障碍物位置，更新(x, y)位置，进行下一步操作
                    x = next_x;
                    y = next_y;
                    // 返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方
                    ans = max(ans, x * x + y * y);
                }
            // 如果cmd = -2，向左转 90 度
            // 方向变化为北->西->南->东->北
            // 对应的dic在方向数组中索引变化为0->3->2->1->0
            }else if(cmd == -2) {
                dir = (dir - 1 + 4) % 4;
            }else
            // 如果cmd = -1，向右转90度
            // 方向变化为北->东->南->西->北
            // 对应的dic在方向数组中索引变化为0->1->2->3->0
            dir = (dir + 1) % 4;
        }
        return ans;
    }

// 问题重点1：判断障碍
// 两个方案：利用hash函数将二元数组转换为string或者大整数，供unordered_set寻找是否有blocker
// 方案1: 转变为string
private:
    string calcHash(int x, int y){
        return to_string(x) + "," + to_string(y); 
    }

// 方案2: 转变为大整数long long
// 将(x, y)看作进制数的第1和第0位，防止为负先平移坐标系再换算
private:
    long long calcHash(int x, int y){
        return (x + 30000) * 60000ll + y + 30000;
    }

};

```

-------

#### LC49 字母异位词分组
https://leetcode-cn.com/problems/group-anagrams/

```Java
// Java
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

        unordered_map<string, vector<string>> groupWords;
        vector<vector<string>> ans;

        for (auto& str : strs){
            string copy = str;
            sort(copy.begin(), copy.end());
            groupWords[copy].push_back(str);
        }

        for (auto pair : groupWords){
            ans.push_back(pair.second);
        }
        return ans;
    }
};
```
-------
#### LC146 LRU缓存机制

```C++

// C++

class LRUCache {
    
    // 初始化
    private class Node{
        int key;
        int value;
        Node pre;
        Node next;
    }

    private HashMap<Integer, Node> map;
    //设置链表保护节点
    private Node head;
    private Node tail;
    // 初始化容量capacity
    private int capacity;

    public LRUCache(int capacity) {
        // 初始化capacity
        this.capacity = capacity;
        // 创建hashmap对象map，integer类型的key和node类型的value
        this.map = new HashMap<Integer, Node>();
        // 双向链表初始化，带有保护节点
        head = new Node();
        tail = new Node();
        // 将head与tail双向连接
        head.next = tail;
        tail.pre = head;
    }
    
    // 访问双向链表
    /* 这里需要将双向链表的访问操作的复杂度降至O(1)
       利用hashmap的key-value结构get(key)方法获取key对应的value，即node
    */
    public int get(int key) {
        // 如果关键字key不存在于缓存中，返回-1
        if (this.map.containsKey(key) == false) return -1; // 检查hashmap中是否存在指定key对应的映射关系
        // 关键字key存在于缓存中，先找到其对应的node
        Node node = map.get(key);
        // 将node从现双向链表和hashmap中删除
        this.removeFromList(node);
        // 将node重新插入到hashmap和双向链表的头部
        this.insertToListHead(node.key, node.value);
        // 返回关键字key的值
        return node.value;
    }

    // 更新双向链表
    public void put(int key, int value) {
        // 如果关键字key存在于缓存中，更新数据值并将其重新插入到双向链表和hashmap的头部
        if (this.map.containsKey(key)) {
            // 关键字key存在于缓存中，先找到其对应的node
            Node node = this.map.get(key);
            // 将node从现双向链表和hashmap中删除
            this.removeFromList(node);
            // 将node重新插入到hashmap和双向链表的头部
            this.insertToListHead(key, value);
        }else{
            // 如果关键字key不存在于缓存中，在双向链表头部插入新的节点
            this.insertToListHead(key, value);
        }
        // 考虑容量上限问题
        // 如果hashmap中key-value pair的数量超出缓存容量，从双向链表和hashmap中删除尾部node和其对应的key-value pair
        if (this.map.size() > capacity){
            // 删除尾部node，即删除尾部保护节点的前一个节点
            this.removeFromList(tail.pre);
        }
    }
    
    // 模板操作：将双向链表中的一个节点删除（同时更新hashmap）
    // 等价于将待删节点的前一个node指向其后一个node，后一个node指向其前一个node，
    private void removeFromList(Node node){
        // 待删节点的前一个node指向其后一个node
        node.pre.next = node.next;
        // 待删节点的后一个node指向其前一个node
        node.next.pre = node.pre;
        // 同时更新hashmap，将node从中删除
        this.map.remove(node.key);
    }

    // 模板操作：在双向链表的头部插入一个节点（同时更新hashmap，返回访问get时已在缓存中的node key-value）
    // 等价于在保护节点head与head.next节点之间插入一个新节点
    private Node insertToListHead(Integer key, Integer value){
        // 新增节点的key-value
        Node node = new Node();
        node.key = key;
        node.value = value;
        // 新增的node指向保护节点原本的后一个node，即head.next
        node.next = head.next;
        // 保护节点原本的后一个node，即head.next，指向新增的node
        head.next.pre = node;
        // 保护节点head的后一个node指向新增的node
        head.next = node;
        // 后一个node指向新增的node指向保护节点head
        node.pre = head;
        // 更新hashmap，在hashmap中增加新的映射关系key指向node
        this.map.put(key, node);
        return node;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```






















