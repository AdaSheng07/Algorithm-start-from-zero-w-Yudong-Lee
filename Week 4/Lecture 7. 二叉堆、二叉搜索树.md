## Lecture 7. 二叉堆、二叉搜索树

### 堆 Heap
堆（Heap）是一种高效维护集合中最大或最小元素的数据结构。  
**大根堆**：根节点最大的堆，用于维护和查询max  
**小根堆**：根节点最小的堆，用于维护和查询min  

堆是一棵**二叉树**，并且满足堆性质（Heap property）
- 大根堆任意结点的关键码key >= 它所有子结点的关键码key（父 >= 子）
- 小根堆任意结点的关键码key <= 它所有子节点的关键码key（父 <= 子）

-------
### 二叉堆 Binary Heap
二叉堆是堆的一种简易实现，本质是一棵满足堆性质的完全二叉树。

**常见操作**  
- 建堆（build）：O(N)
- 查询最值（get max/min）：O(1)
- 插入（insert）：O(log N)
- 取出最值（delete max/min）：O(log N)

*高级数据结构：斐波那契数列、配对堆等可以做到插入O(1)，左偏树、斜堆等可以支持合并

**二叉堆的实现**  
一般使用一个**一维数组**来存储，利用完全二叉树的结点编号特性。

二叉树的结点编号特性：

假设第一个元素存储在索引（下标）为1的位置的话  
- 索引为`p`的结点的左孩子的索引为`p * 2`
- 索引为`p`的结点的右孩子的索引为`p * 2 + 1`
- 索引为`p`的结点的父亲结点的索引为`p / 2`（向下取整）

假设第一个元素存储在索引（下标）为0的位置的话  
- 索引为`p`的结点的左孩子的索引为`p * 2 + 1`
- 索引为`p`的结点的右孩子的索引为`p * 2 + 2`
- 索引为`p`的结点的父亲结点的索引为`(p - 1) / 2`（向下取整）

**插入（insert）**  
新元素一律插入到数组heap的尾部，假设插入到数组`heap`的尾部，然后向上进行一次调整（Heapify Up）：
- 若已到达根，停止
- 若满足堆性质（`heap[p] <= heap[p/2]`），停止
- 否则交换`heap[p]`和`heap[p/2]`，令`p = p / 2`， 继续调整  

插入操作时间复杂度为`O(log N)`

**取出堆顶（extract/delete max）**  
把堆顶（heap[1]）与堆尾（heap[n]）交换，删除堆尾（数组最后一个元素），然后从根向下进行一次调整（Heapify Down）
- 每次与左、右子节点中较大的一个进行比较，检查堆性质，不满足则交换
- 注意判断子节点是否存在  

取出堆顶操作时间复杂度为`O(log N)`

-------
### 优先队列（priority queue）
二叉堆是优先队列（priority queue）一种简单、常见的实现，但不是最优实现  
理论上二叉堆可以支持`O(log N)`删除任意元素，只需要
- 定位该元素在堆中的结点p（可以通过在数值与索引之间建立映射得到）
- 与堆尾交换，删除堆尾
- 从p向上、向下各进行一次调整

但优先队列没有内置这个方法，在各语言内置的库中，需要支持伤处任意元素时，一般使用有序集合等基于平衡二叉搜索树的实现

-------
### 二叉搜索树（binary search tree）
二叉搜索树（binary search tree）是一棵满足如下性质（BST性质）的二叉树：
- 任意结点的关键码key >= 它左子树中所有结点的关键码key
- 任意结点的关键码key <= 它右子树中所有结点的关键码key  

根据以上性质，我们知道，二叉搜索树的中序遍历必然为一个有序序列

**BST的建立**  
为了避免越界，减少便捷情况的特殊判断，一般在BST中额外插入两个保护结点
- 一个关键码为正无穷（一个很大的正整数）
- 一个关键码为负无穷  

仅由这两个结点构成的BST就是一棵初始的空BST

**BST的检索**  
检索关键码val是否存在，从根开始递归查找：
- 若当前结点的关键码等于val，则已经找到
- 若关键码大于val，递归检索左子树（或不存在）
- 若关键码小于val，递归检索右子树（或不存在）

**BST的插入**  
插入val与检索val的过程类似：
- 若检索发现存在，则放弃插入（或者把val对应结点的计数+1，视要求而定）
- 若检索发现不存在（子树为空），直接在对饮位置新建关键码为val的结点

**BST 求前驱/后继**
前驱：BST中小于val的最大结点  
后继：BST中大于val的最小结点  
求前驱和后继也是基于检索的，先检索val  
以求后继为例：
- 如果检索到了val，并且val存在右子树，则在右子树中一直往左走到底
- 否则说明没找到val或者val没有右子树，此时前驱就在检索过程经过的结点中（即当前结点的所有祖先结点，可以拿一个变量顺便求一下）

**BST的删除**  
从BST中删除关键码为val的结点，可以基于检索+求后继实现：
- 首先检索val
- 如果val只有一棵子树，直接删除val，把子树和父节点相连就行了
- 如果有两棵子树，需要找到后继，先删除后继，再用后继结点代替val的位置（因为后继是右子树一直往左走到底，所以它最多只会有一棵子树）

二叉搜索树查询/插入/求前驱/求后继/删除操作的时间复杂度：
- 随机数据期望`O(log N)`
- 在非随机数据上，BST容易退化为`O(N)`，一般都要结合旋转操作来进行平衡
- 与平衡二叉树内容相关











